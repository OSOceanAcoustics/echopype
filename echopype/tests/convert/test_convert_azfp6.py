"""test_convert_azfp.py

This module contains tests that:
- verify echopype converted files against those from AZFP Matlab scripts and EchoView
- convert AZFP file with different range settings across frequency
"""

import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from scipy.io import loadmat
from echopype import open_raw
import pytest
from echopype.convert.parse_azfp6 import ParseAZFP6


@pytest.fixture
def azfp_path(test_path):
    return test_path["AZFP6"]


def check_platform_required_scalar_vars(echodata):
    # check convention-required variables in the Platform group
    for var in [
        "MRU_offset_x",
        "MRU_offset_y",
        "MRU_offset_z",
        "MRU_rotation_x",
        "MRU_rotation_y",
        "MRU_rotation_z",
        "position_offset_x",
        "position_offset_y",
        "position_offset_z",
    ]:
        assert var in echodata["Platform"]
        assert np.isnan(echodata["Platform"][var])


@pytest.mark.skip(reason="tests for comparing AZFP XML parsing with Matlab outputs have not been implemented")
def test_convert_azfp_02a_xml_parsing(azfp_path):
    """Compare the embedded XML parsed data with Matlab loaded XML file."""

def test_convert_azfp_01a_matlab_raw(azfp_path):
    """Compare parsed raw data with Matlab outputs."""
    azfp_01a_path = azfp_path / '24052113_01A.azfp'
    azfp_matlab_data_path = azfp_path / 'from_matlab/24052113_01A.mat'
    azfp_matlab_output_path = azfp_path / 'from_matlab/24052113_01A_Output.mat'
    
    # Convert file
    echodata = open_raw(
        raw_file=azfp_01a_path, sonar_model='AZFP6'
    )

    # Read in the dataset that will be used to confirm working conversions. (Generated by Matlab)
    ds_matlab = loadmat(azfp_matlab_data_path)
    ds_matlab_output = loadmat(azfp_matlab_output_path)

    # Test beam group
    # frequency
    assert np.array_equal(
        ds_matlab['Data']['Freq'][0][0][:, 0],
        echodata["Sonar/Beam_group1"].frequency_nominal / 1000,
    )  # matlab file in kHz
    # backscatter count
    assert np.array_equal(
        np.array(
            [ds_matlab_output['Output'][0]['N'][fidx] for fidx in range(4)]
        ),
        echodata["Sonar/Beam_group1"].backscatter_r.values,
    )
    
    # Test vendor group
    # Test temperature
    assert np.array_equal(
        np.array([d[4] for d in ds_matlab['Data']['Ancillary'][0]]).squeeze(),
        echodata["Vendor_specific"].ancillary.isel(ancillary_len=4),
    )
    assert np.allclose(
        ds_matlab_output['Output']['BatteryTx'][0][0].squeeze(),
        echodata["Vendor_specific"].battery_tx,
        rtol=1e-08
    )
    assert np.allclose(
        ds_matlab_output['Output']['BatteryMain'][0][0].squeeze(),
        echodata["Vendor_specific"].battery_main,
        atol=1e-12
    )
    
    # tilt x-y
    assert np.array_equal(
        np.array([d[0] for d in ds_matlab['Data']['Ancillary'][0]]).squeeze(),
        echodata["Vendor_specific"].tilt_x_count,
    )
    assert np.array_equal(
        np.array([d[1] for d in ds_matlab['Data']['Ancillary'][0]]).squeeze(),
        echodata["Vendor_specific"].tilt_y_count,
    )
    
    # check convention-required variables in the Platform group
    check_platform_required_scalar_vars(echodata)


def test_convert_azfp_01a_matlab_derived(azfp_path):
    """Compare variables derived from raw parsed data with Matlab outputs."""

    # # check convention-required variables in the Platform group
    azfp_01a_path = azfp_path / '24052113_01A.azfp'
    azfp_matlab_data_path = azfp_path / 'from_matlab/24052113_01A.mat'
    azfp_matlab_output_path = azfp_path / 'from_matlab/24052113_01A_Output.mat'
    
    ds_matlab_output = loadmat(azfp_matlab_output_path)
    
    # Convert file
    echodata = open_raw(
        raw_file=azfp_01a_path, sonar_model='AZFP6'
    )
    
    #check derive tilt x 
    assert np.array_equal(
                ds_matlab_output['Output']['Tx'][0][0].squeeze(),
                echodata["Platform"].tilt_x
    )
    #check derived tilt y
    assert np.array_equal(
                ds_matlab_output['Output']['Ty'][0][0].squeeze(),
                echodata["Platform"].tilt_y
    )
    #check derived temperature, accept minor rounding differences
    assert np.allclose(
                ds_matlab_output['Output']['T'][0][0].squeeze(),
                echodata["Environment"].temperature,
                atol=1e-12
    )

    #check derived ping_time
    #NOTE: Only require a second precision accuracy as Matlab has some rounding errors at the nsec level if 
    # the *.mat is run on Windows
    f = lambda x: np.datetime64(datetime.fromordinal(int(x)) + timedelta(days=x%1) - timedelta(days = 366), "[s]")
    assert np.array_equal(
        np.vectorize(f)(ds_matlab_output["Output"]['Date'][0][0].squeeze()),
        echodata["Vendor_specific"].ping_time
    )

    check_platform_required_scalar_vars(echodata)

def test_convert_azfp_02a_gps_lat_long(azfp_path):
    """Test converting file with valid optional latitude/longitude."""
    
    # TODO: GPS date time values.  Current file has invalid values 
    
    # # check convention-required variables in the Platform group
    azfp_02a_path = azfp_path / '21102500_02A.azfp'
    azfp_matlab_data_path = azfp_path / 'from_matlab/21102500_02A.mat'
    
    ds_matlab = loadmat(azfp_matlab_data_path)
    
    # Convert file
    echodata = open_raw(
        raw_file=azfp_02a_path, sonar_model='AZFP6'
    )
    
    assert np.array_equal(
        #ds_matlab['Data']['GPS_LAT_LONG'][0,0],
        np.array([[d[0],d[1]] for d in ds_matlab['Data']['GPS_LAT_LONG'][0]]).squeeze().T,
        np.stack([echodata["Platform"].latitude, echodata["Platform"].longitude])
    )
    
    check_platform_required_scalar_vars(echodata)
